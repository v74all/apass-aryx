#!/usr/bin/env python3

import sys 
import os 
import argparse 
import subprocess 
import json 
import time 
import asyncio 
import concurrent .futures 
from pathlib import Path 
from datetime import datetime 
import shutil 
import threading 
import tempfile 
import hashlib 
import zipfile 
from typing import Dict ,List ,Optional ,Tuple ,Union ,Set ,Any ,Callable 


SUITE_DIR =Path (__file__ ).resolve ().parents [1 ]
sys .path .insert (0 ,str (SUITE_DIR ))

from utils .logger import Logger 
from utils .device_manager import DeviceManager 
from utils .report_generator import ReportGenerator 
from utils .threat_intelligence import ThreatIntelligence 


class EnhancedMalwareAnalyzer :

    def __init__ (self ,config_path :Optional [str ]=None ):
        self .suite_dir =SUITE_DIR 

        if config_path :
            self .config_path =Path (config_path )
        else :
            candidate1 =self .suite_dir /"config"/"analysis_config.json"
            candidate2 =self .suite_dir .parent /"resources"/"analysis_config.json"
            self .config_path =candidate1 if candidate1 .exists ()else candidate2 

        self .logger =Logger (self .suite_dir /"output"/"analysis.log")
        self .device_manager =DeviceManager (logger =self .logger )
        self .report_generator =ReportGenerator (self .suite_dir /"output",logger =self .logger )
        self .threat_intel =ThreatIntelligence ()


        self .config =self .load_config ()


        self .analysis_id =self .generate_analysis_id ()
        self .start_time =None 
        self .running_processes =[]
        self .executor =concurrent .futures .ThreadPoolExecutor (
        max_workers =self .config ["analysis"].get ("max_workers",4 )
        )


        self ._temp_dirs :List [Path ]=[]
        self ._max_memory_usage =self .config ["analysis"].get ("max_memory_mb",2048 )*1024 *1024 


        self .supported_formats ={
        "apk":self ._analyze_apk ,
        "aab":self ._analyze_app_bundle ,
        "xapk":self ._analyze_xapk ,
        "apks":self ._analyze_split_apk ,
        }

        self .logger .info ("Enhanced Malware Analysis Suite v5.0 initialized")

    def load_config (self )->Dict :
        default_config ={
        "analysis":{
        "timeout":300 ,
        "frida_port":27042 ,
        "output_formats":["json","txt","html"],
        "threat_scoring":True ,
        "real_time_monitoring":True ,
        "dynamic_analysis_duration":120 ,
        "max_workers":4 ,
        "max_memory_mb":2048 ,
        "cloud_storage":False ,
        "parallel_processing":True ,
        },
        "tools":{
        "static_analyzer":True ,
        "dynamic_analyzer":True ,
        "memory_analyzer":True ,
        "network_analyzer":True ,
        "behavior_analyzer":True ,
        },
        "reporting":{
        "generate_iocs":True ,
        "generate_yara":True ,
        "generate_mitre":True ,
        "threat_intelligence":True ,
        "visualizations":True ,
        "export_to_cloud":False ,
        },
        "cloud":{
        "provider":"none",
        "storage_path":"",
        "credentials_file":"",
        "bucket_name":"",
        },
        }

        if self .config_path and self .config_path .exists ():
            try :
                with open (self .config_path ,"r",encoding ="utf-8")as f :
                    user_config =json .load (f )

                self ._deep_merge (default_config ,user_config )
            except Exception as e :
                self .logger .warning (f"Failed to load config: {e }, using defaults")

        return default_config 

    def _deep_merge (self ,target :Dict ,source :Dict )->None :
        for key ,value in source .items ():
            if isinstance (value ,dict )and key in target and isinstance (target [key ],dict ):
                self ._deep_merge (target [key ],value )
            else :
                target [key ]=value 

    def generate_analysis_id (self )->str :
        timestamp =datetime .now ().strftime ("%Y%m%d_%H%M%S")
        return f"analysis_{timestamp }"

    def setup_environment (self )->bool :
        self .logger .info ("Setting up analysis environment...")

        if not self .check_prerequisites ():
            return False 

        if not self .device_manager .setup ():
            self .logger .warning ("Device setup failed, but continuing with available features")


        self .create_output_directories ()


        temp_dir =Path (tempfile .mkdtemp (prefix =f"malware_analysis_{self .analysis_id }_"))
        self ._temp_dirs .append (temp_dir )

        self .logger .success ("Environment setup complete")
        return True 

    def check_prerequisites (self )->bool :
        required_tools =["adb","frida","python3"]
        missing_tools =[tool for tool in required_tools if not shutil .which (tool )]

        if missing_tools :
            self .logger .error (f"Missing required tools: {', '.join (missing_tools )}")
            return False 

        optional_tools =["jadx","apktool","dex2jar"]
        missing_optional =[tool for tool in optional_tools if not shutil .which (tool )]
        if missing_optional :
            self .logger .warning (f"Missing optional tools: {', '.join (missing_optional )}. Some features may be limited.")


        required_packages =["androguard","lief","rich","requests","frida","aiohttp","numpy"]
        missing_packages =[]

        for package in required_packages :
            try :
                __import__ (package )
            except ImportError :
                missing_packages .append (package )

        if missing_packages :
            self .logger .warning (f"Missing Python dependencies: {', '.join (missing_packages )}. Attempting to install...")
            try :
                subprocess .run (
                [sys .executable ,"-m","pip","install"]+missing_packages ,
                check =True ,
                capture_output =True 
                )
                self .logger .success ("Successfully installed missing dependencies")
            except subprocess .CalledProcessError :
                self .logger .error (
                f"Failed to install dependencies. Please run 'pip install {' '.join (missing_packages )}'"
                )
                return False 

        return True 

    def create_output_directories (self ):
        output_base =self .suite_dir /"output"/self .analysis_id 
        directories =["static","dynamic","memory","network","reports","artifacts","visualizations"]

        for directory in directories :
            (output_base /directory ).mkdir (parents =True ,exist_ok =True )

    async def analyze_sample_async (self ,package_path :str ,package_name :Optional [str ]=None )->bool :
        self .start_time =time .time ()
        package_path_obj =Path (package_path )

        if not package_path_obj .exists ():
            self .logger .error (f"Package file not found: {package_path_obj }")
            return False 


        package_type =self ._detect_package_type (package_path_obj )
        if not package_type :
            self .logger .error (f"Unsupported package format: {package_path_obj .suffix }")
            return False 

        self .logger .info (f"Detected package type: {package_type }")


        analysis_dir =self .suite_dir /"output"/self .analysis_id /"artifacts"
        sample_copy =analysis_dir /package_path_obj .name 
        shutil .copy2 (package_path_obj ,sample_copy )


        file_hash =self ._calculate_file_hash (sample_copy )

        self .logger .info (f"Starting analysis of: {package_path_obj .name } (SHA256: {file_hash })")
        self .logger .info (f"Analysis ID: {self .analysis_id }")

        analysis_results ={
        "metadata":{
        "analysis_id":self .analysis_id ,
        "package_name":package_path_obj .name ,
        "package_type":package_type ,
        "sha256":file_hash ,
        "timestamp":datetime .now ().isoformat (),
        }
        }

        try :

            analyzer_func =self .supported_formats .get (package_type )
            if not analyzer_func :
                self .logger .error (f"No analyzer available for package type: {package_type }")
                return False 

            analysis_results =await analyzer_func (sample_copy ,package_name ,analysis_results )


            duration =time .time ()-self .start_time 
            analysis_results ["metadata"]["duration"]=duration 

            if not await self ._generate_reports_async (analysis_results ,package_path_obj .name ,package_name ):
                self .logger .error ("Report generation failed")
                return False 


            if self .config ["reporting"].get ("export_to_cloud",False ):
                await self ._upload_to_cloud (analysis_results )

            self .logger .success (
            f"Analysis completed successfully in {duration :.2f} seconds."
            )
            return True 

        except KeyboardInterrupt :
            self .logger .warning ("Analysis interrupted by user")
            await self ._cleanup_async ()
            return False 
        except Exception as e :
            self .logger .error (
            f"An unexpected error occurred during analysis: {e }",exc_info =True 
            )
            await self ._cleanup_async ()
            return False 

    def analyze_sample (self ,package_path :str ,package_name :Optional [str ]=None )->bool :

        loop =asyncio .new_event_loop ()
        try :
            return loop .run_until_complete (self .analyze_sample_async (package_path ,package_name ))
        finally :
            loop .close ()

    def _detect_package_type (self ,file_path :Path )->Optional [str ]:
        extension =file_path .suffix .lower ()[1 :]


        if extension in self .supported_formats :
            return extension 


        try :
            with open (file_path ,"rb")as f :
                header =f .read (16 )


            if header .startswith (b"PK\x03\x04"):

                with zipfile .ZipFile (file_path ,'r')as zip_file :
                    file_list =zip_file .namelist ()

                    if "BundleConfig.pb"in file_list or "base/manifest/AndroidManifest.xml"in file_list :
                        return "aab"
                    elif "AndroidManifest.xml"in file_list :
                        return "apk"
                    elif any ("config.json"in f for f in file_list ):
                        return "xapk"


            return "apk"
        except Exception :

            self .logger .warning (f"Could not determine package type by content for {file_path }. Defaulting to APK.")
            return "apk"

    def _calculate_file_hash (self ,file_path :Path )->str :
        sha256_hash =hashlib .sha256 ()
        with open (file_path ,"rb")as f :
            for byte_block in iter (lambda :f .read (4096 ),b""):
                sha256_hash .update (byte_block )
        return sha256_hash .hexdigest ()

    async def _analyze_apk (self ,apk_path :Path ,package_name :Optional [str ],results :Dict )->Dict :

        static_output_dir =self .suite_dir /"output"/self .analysis_id /"static"
        static_results =await self ._run_static_analysis_async (apk_path ,static_output_dir )
        if static_results :
            results ["static"]=static_results 
            if not package_name :
                package_name =static_results .get ("manifest_analysis",{}).get ("package_name")
                if package_name :
                    self .logger .info (f"Package name detected from manifest: {package_name }")


        if self .config ["tools"]["dynamic_analyzer"]and package_name :
            dynamic_output_dir =self .suite_dir /"output"/self .analysis_id /"dynamic"
            dynamic_results =await self ._run_dynamic_analysis_async (apk_path ,package_name ,dynamic_output_dir )
            if dynamic_results :
                results ["dynamic"]=dynamic_results 


        if self .config ["tools"]["memory_analyzer"]and package_name :
            memory_output_dir =self .suite_dir /"output"/self .analysis_id /"memory"
            memory_results =await self ._run_memory_analysis_async (package_name ,memory_output_dir )
            if memory_results :
                results ["memory"]=memory_results 


        if self .config ["tools"]["network_analyzer"]and package_name :
            network_output_dir =self .suite_dir /"output"/self .analysis_id /"network"
            network_results =await self ._run_network_analysis_async (package_name ,network_output_dir )
            if network_results :
                results ["network"]=network_results 

        return results 

    async def _analyze_app_bundle (self ,aab_path :Path ,package_name :Optional [str ],results :Dict )->Dict :
        self .logger .info ("Processing Android App Bundle (AAB)")


        output_dir =self .suite_dir /"output"/self .analysis_id /"artifacts"/"extracted_apks"
        output_dir .mkdir (parents =True ,exist_ok =True )

        try :

            bundletool_path =self .config .get ("tools",{}).get ("bundletool_path","bundletool.jar")
            if not Path (bundletool_path ).exists ():
                self .logger .error ("Bundletool not found. Please add 'bundletool_path' to your config.")
                return results 


            apks_output =output_dir /f"{aab_path .stem }.apks"
            cmd =[
            "java","-jar",bundletool_path ,"build-apks",
            f"--bundle={aab_path }",
            f"--output={apks_output }",
            "--mode=universal"
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,stdout =asyncio .subprocess .PIPE ,stderr =asyncio .subprocess .PIPE 
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Failed to convert AAB to APKs: {stderr .decode ()}")
                return results 


            extract_dir =output_dir /"extracted"
            extract_dir .mkdir (exist_ok =True )


            cmd =["unzip","-o",str (apks_output ),"-d",str (extract_dir )]
            process =await asyncio .create_subprocess_exec (
            *cmd ,stdout =asyncio .subprocess .PIPE ,stderr =asyncio .subprocess .PIPE 
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Failed to extract APKs: {stderr .decode ()}")
                return results 


            universal_apk =list (extract_dir .glob ("universal.apk"))
            if not universal_apk :
                self .logger .error ("Could not find universal.apk in extracted files")
                return results 


            self .logger .info (f"Successfully extracted APK from AAB: {universal_apk [0 ]}")
            return await self ._analyze_apk (universal_apk [0 ],package_name ,results )

        except Exception as e :
            self .logger .error (f"Error processing AAB file: {e }",exc_info =True )
            return results 

    async def _analyze_xapk (self ,xapk_path :Path ,package_name :Optional [str ],results :Dict )->Dict :
        self .logger .info ("Processing XAPK package")

        output_dir =self .suite_dir /"output"/self .analysis_id /"artifacts"/"extracted_xapk"
        output_dir .mkdir (parents =True ,exist_ok =True )

        try :
            with zipfile .ZipFile (xapk_path ,'r')as zip_ref :
                zip_ref .extractall (output_dir )


            main_apk =None 
            config_file =None 

            for file in output_dir .glob ("**/*.apk"):
                if "main.apk"in file .name .lower ()or "base.apk"in file .name .lower ():
                    main_apk =file 
                    break 

            if not main_apk :

                apk_files =list (output_dir .glob ("**/*.apk"))
                if apk_files :
                    main_apk =apk_files [0 ]

            for file in output_dir .glob ("**/config.json"):
                config_file =file 
                break 

            if not main_apk :
                self .logger .error ("Could not find a valid APK in the XAPK package")
                return results 


            if config_file :
                try :
                    with open (config_file ,'r')as f :
                        config_data =json .load (f )
                        results ["xapk_metadata"]=config_data 
                        if not package_name and "package_name"in config_data :
                            package_name =config_data ["package_name"]
                except Exception as e :
                    self .logger .warning (f"Failed to parse XAPK config file: {e }")


            self .logger .info (f"Analyzing main APK from XAPK: {main_apk }")
            results =await self ._analyze_apk (main_apk ,package_name ,results )


            other_apks =[f for f in output_dir .glob ("**/*.apk")if f !=main_apk ]
            if other_apks :
                results ["xapk_additional_apks"]=[str (apk .relative_to (output_dir ))for apk in other_apks ]
                self .logger .info (f"XAPK contains {len (other_apks )} additional APKs")

            return results 

        except Exception as e :
            self .logger .error (f"Error processing XAPK file: {e }",exc_info =True )
            return results 

    async def _analyze_split_apk (self ,apks_path :Path ,package_name :Optional [str ],results :Dict )->Dict :
        self .logger .info ("Processing split APK package")

        output_dir =self .suite_dir /"output"/self .analysis_id /"artifacts"/"extracted_split_apk"
        output_dir .mkdir (parents =True ,exist_ok =True )

        try :
            with zipfile .ZipFile (apks_path ,'r')as zip_ref :
                zip_ref .extractall (output_dir )


            base_apk =None 
            for file in output_dir .glob ("**/*.apk"):
                if "base"in file .name .lower ():
                    base_apk =file 
                    break 

            if not base_apk :

                apk_files =list (output_dir .glob ("**/*.apk"))
                if apk_files :
                    base_apk =apk_files [0 ]

            if not base_apk :
                self .logger .error ("Could not find a valid APK in the split APK package")
                return results 


            self .logger .info (f"Analyzing base APK from split package: {base_apk }")
            results =await self ._analyze_apk (base_apk ,package_name ,results )


            other_apks =[f for f in output_dir .glob ("**/*.apk")if f !=base_apk ]
            if other_apks :
                results ["split_apk_components"]=[str (apk .relative_to (output_dir ))for apk in other_apks ]
                self .logger .info (f"Split APK contains {len (other_apks )} additional components")

            return results 

        except Exception as e :
            self .logger .error (f"Error processing split APK file: {e }",exc_info =True )
            return results 

    async def _run_static_analysis_async (self ,apk_path :Path ,output_dir :Path )->Optional [Dict ]:
        self .logger .info ("=== PHASE 1: STATIC ANALYSIS ===")
        output_json_path =output_dir /f"static_analysis_{self .analysis_id }.json"

        cmd =[
        sys .executable ,
        str (self .suite_dir /"tools"/"enhanced_static_analyzer.py"),
        str (apk_path ),
        "--output-file",
        str (output_json_path ),
        ]

        logger_config_json =self .logger .to_json ()
        env =os .environ .copy ()
        env ["LOGGER_CONFIG"]=logger_config_json 

        try :
            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            env =env ,
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Static analysis process failed with return code {process .returncode }.")
                if stderr :
                    self .logger .error (f"Stderr: {stderr .decode ('utf-8',errors ='replace')}")
                return None 

            if stdout :
                self .logger .info ("Static analyzer output:")
                self .logger .info (stdout .decode ('utf-8',errors ='replace'))

            if output_json_path .exists ():
                async with asyncio .Lock ():
                    with open (output_json_path ,"r",encoding ="utf-8")as f :
                        static_results =json .load (f )
                self .logger .success ("Static analysis completed and results loaded.")
                return static_results 
            else :
                self .logger .error (
                "Static analysis script ran but did not produce an output file."
                )
                return None 

        except asyncio .TimeoutError :
            self .logger .error (
            f"Static analysis timed out after {self .config ['analysis'].get ('timeout',300 )} seconds."
            )
            return None 
        except Exception as e :
            self .logger .error (
            f"An unexpected error occurred during static analysis: {e }",
            exc_info =True ,
            )
            return None 

    async def _run_dynamic_analysis_async (
    self ,apk_path :Path ,package_name :str ,output_dir :Path 
    )->Optional [Dict ]:
        self .logger .info ("=== PHASE 2: DYNAMIC ANALYSIS ===")

        if not await self .device_manager .is_device_ready_async ():
            self .logger .error ("Device not ready for dynamic analysis. Skipping.")
            return None 

        try :
            self .logger .info ("Preparing device for dynamic analysis...")
            if not await self .device_manager .setup_for_dynamic_analysis_async (apk_path ,package_name ):
                self .logger .error ("Failed to prepare device for dynamic analysis.")
                return None 

            self .logger .info ("Device setup complete. Starting dynamic analyzer...")
            output_json_path =output_dir /f"dynamic_analysis_{self .analysis_id }.json"

            cmd =[
            sys .executable ,
            str (self .suite_dir /"tools"/"enhanced_dynamic_analyzer.py"),
            "--package",
            package_name ,
            "--script",
            str (self .suite_dir /"scripts"/"comprehensive_instrumentation.js"),
            "--output-file",
            str (output_json_path ),
            "--device-id",
            self .device_manager .device_id ,
            "--duration",
            str (self .config ["analysis"]["dynamic_analysis_duration"]),
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            )
            stdout ,stderr =await asyncio .wait_for (
            process .communicate (),
            timeout =max (
            60 ,
            int (self .config ["analysis"].get ("dynamic_analysis_duration",120 ))
            +30 ,
            ),
            )

            if process .returncode !=0 :
                self .logger .error (f"Dynamic analysis process failed with return code {process .returncode }.")
                if stderr :
                    self .logger .error (f"Stderr: {stderr .decode ('utf-8',errors ='replace')}")
                return None 

            if stdout :
                self .logger .info ("Dynamic analyzer output:")
                self .logger .info (stdout .decode ('utf-8',errors ='replace'))

            if output_json_path .exists ():
                async with asyncio .Lock ():
                    with open (output_json_path ,"r",encoding ="utf-8")as f :
                        dynamic_results =json .load (f )
                self .logger .success ("Dynamic analysis completed and results loaded.")
                return dynamic_results 
            else :
                self .logger .error (
                "Dynamic analysis script ran but did not produce an output file."
                )
                return None 

        except asyncio .TimeoutError :
            self .logger .error ("Dynamic analysis timed out.")
            return None 
        except Exception as e :
            self .logger .error (
            f"An unexpected error occurred during dynamic analysis: {e }",
            exc_info =True ,
            )
            return None 
        finally :
            self .logger .info ("Cleaning up device after dynamic analysis.")
            await self .device_manager .cleanup_after_analysis_async (package_name )

    async def _run_memory_analysis_async (
    self ,package_name :str ,output_dir :Path 
    )->Optional [Dict ]:
        self .logger .info ("=== RUNNING MEMORY ANALYSIS ===")
        output_json_path =output_dir /f"memory_analysis_{self .analysis_id }.json"

        try :
            cmd =[
            sys .executable ,
            str (self .suite_dir /"tools"/"memory_analyzer.py"),
            "--package",
            package_name ,
            "--output-file",
            str (output_json_path ),
            "--device-id",
            self .device_manager .device_id ,
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Memory analysis process failed with return code {process .returncode }.")
                if stderr :
                    self .logger .error (f"Stderr: {stderr .decode ('utf-8',errors ='replace')}")
                return None 

            if stdout :
                self .logger .info ("Memory analyzer output:")
                self .logger .info (stdout .decode ('utf-8',errors ='replace'))

            if output_json_path .exists ():
                async with asyncio .Lock ():
                    with open (output_json_path ,"r",encoding ="utf-8")as f :
                        memory_results =json .load (f )
                self .logger .success ("Memory analysis completed and results loaded.")
                return memory_results 
            else :
                self .logger .error (
                "Memory analysis script ran but did not produce an output file."
                )
                return None 

        except Exception as e :
            self .logger .error (
            f"An unexpected error occurred during memory analysis: {e }",
            exc_info =True ,
            )
            return None 

    async def _run_network_analysis_async (
    self ,package_name :str ,output_dir :Path 
    )->Optional [Dict ]:
        self .logger .info ("=== RUNNING NETWORK ANALYSIS ===")
        output_json_path =output_dir /f"network_analysis_{self .analysis_id }.json"

        try :
            cmd =[
            sys .executable ,
            str (self .suite_dir /"tools"/"network_analyzer.py"),
            "--package",
            package_name ,
            "--output-file",
            str (output_json_path ),
            "--device-id",
            self .device_manager .device_id ,
            "--duration",
            str (self .config ["analysis"]["dynamic_analysis_duration"]),
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Network analysis process failed with return code {process .returncode }.")
                if stderr :
                    self .logger .error (f"Stderr: {stderr .decode ('utf-8',errors ='replace')}")
                return None 

            if stdout :
                self .logger .info ("Network analyzer output:")
                self .logger .info (stdout .decode ('utf-8',errors ='replace'))

            if output_json_path .exists ():
                async with asyncio .Lock ():
                    with open (output_json_path ,"r",encoding ="utf-8")as f :
                        network_results =json .load (f )
                self .logger .success ("Network analysis completed and results loaded.")
                return network_results 
            else :
                self .logger .error (
                "Network analysis script ran but did not produce an output file."
                )
                return None 

        except Exception as e :
            self .logger .error (
            f"An unexpected error occurred during network analysis: {e }",
            exc_info =True ,
            )
            return None 

    async def _generate_reports_async (
    self ,analysis_results :Dict ,apk_name :str ,package_name :Optional [str ]
    )->bool :
        self .logger .info ("=== PHASE 3: REPORT GENERATION ===")
        try :
            report_dir =self .suite_dir /"output"/self .analysis_id /"reports"


            loop =asyncio .get_event_loop ()
            await loop .run_in_executor (
            self .executor ,
            self .report_generator .generate ,
            analysis_results ,
            self .analysis_id ,
            apk_name ,
            package_name ,
            self .config ["analysis"]["output_formats"],
            )


            if self .config ["reporting"].get ("visualizations",False ):
                viz_dir =self .suite_dir /"output"/self .analysis_id /"visualizations"
                await self ._generate_visualizations (analysis_results ,viz_dir )

            self .logger .success (f"Reports generated in: {report_dir }")
            return True 
        except Exception as e :
            self .logger .error (
            f"An error occurred during report generation: {e }",exc_info =True 
            )
            return False 

    async def _generate_visualizations (self ,analysis_results :Dict ,output_dir :Path )->bool :
        try :
            cmd =[
            sys .executable ,
            str (self .suite_dir /"tools"/"visualization_generator.py"),
            "--data",json .dumps (analysis_results ),
            "--output-dir",str (output_dir ),
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Visualization generation failed: {stderr .decode ()}")
                return False 

            self .logger .success ("Visualizations generated successfully")
            return True 
        except Exception as e :
            self .logger .error (f"Error generating visualizations: {e }")
            return False 

    async def _upload_to_cloud (self ,analysis_results :Dict )->bool :
        provider =self .config ["cloud"].get ("provider","none")
        if provider =="none":
            return False 

        self .logger .info (f"Uploading analysis results to {provider } cloud storage...")

        try :
            cmd =[
            sys .executable ,
            str (self .suite_dir /"utils"/"cloud_uploader.py"),
            "--provider",provider ,
            "--analysis-id",self .analysis_id ,
            "--config",json .dumps (self .config ["cloud"]),
            "--output-dir",str (self .suite_dir /"output"/self .analysis_id ),
            ]

            process =await asyncio .create_subprocess_exec (
            *cmd ,
            stdout =asyncio .subprocess .PIPE ,
            stderr =asyncio .subprocess .PIPE ,
            )
            stdout ,stderr =await process .communicate ()

            if process .returncode !=0 :
                self .logger .error (f"Cloud upload failed: {stderr .decode ()}")
                return False 

            self .logger .success (f"Analysis results uploaded to {provider } cloud storage")
            return True 
        except Exception as e :
            self .logger .error (f"Error uploading to cloud: {e }")
            return False 

    async def _cleanup_async (self ):
        self .logger .info ("Cleaning up analysis environment...")


        for p in self .running_processes :
            if not p .poll ():
                try :
                    p .kill ()
                except :
                    pass 


        for temp_dir in self ._temp_dirs :
            try :
                shutil .rmtree (temp_dir ,ignore_errors =True )
            except :
                pass 
        self ._temp_dirs .clear ()


        await self .device_manager .cleanup_async ()


        self .executor .shutdown (wait =False )

        self .logger .info ("Cleanup complete.")

    def cleanup (self ):
        loop =asyncio .new_event_loop ()
        try :
            loop .run_until_complete (self ._cleanup_async ())
        finally :
            loop .close ()


def main ():
    parser =argparse .ArgumentParser (
    description ="Enhanced Malware Analysis Suite v5.0",
    formatter_class =argparse .RawTextHelpFormatter ,
    )
    parser .add_argument ("package_path",help ="Path to the Android package file to analyze (APK, AAB, XAPK, or APKS).")
    parser .add_argument (
    "-p",
    "--package",
    help ="Specify the package name (optional, will be auto-detected if possible).",
    )
    parser .add_argument (
    "-c","--config",help ="Path to a custom analysis_config.json file."
    )
    parser .add_argument (
    "--async",action ="store_true",dest ="use_async",
    help ="Use async mode for better performance (recommended)."
    )
    parser .add_argument (
    "--cloud-upload",action ="store_true",
    help ="Upload results to configured cloud storage."
    )

    args =parser .parse_args ()


    analyzer =EnhancedMalwareAnalyzer (config_path =args .config )


    if args .cloud_upload :
        analyzer .config ["reporting"]["export_to_cloud"]=True 


    if not analyzer .setup_environment ():
        analyzer .logger .critical (
        "Failed to set up the analysis environment. Aborting."
        )
        sys .exit (1 )


    success =False 
    try :
        if args .use_async :

            loop =asyncio .get_event_loop ()
            success =loop .run_until_complete (
            analyzer .analyze_sample_async (args .package_path ,args .package )
            )
        else :

            success =analyzer .analyze_sample (args .package_path ,args .package )
    except KeyboardInterrupt :
        analyzer .logger .warning ("Analysis interrupted by user")
    finally :
        analyzer .cleanup ()

    if not success :
        analyzer .logger .critical ("Analysis failed. Check logs for details.")
        sys .exit (1 )


if __name__ =="__main__":
    main ()
